<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
/***************************************************************************************
 * This code was generated by a tool.                                                  *
 * Please do not modify this file directly - modify PrtgClient.AsyncHelpers.tt instead *
 ***************************************************************************************/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using System.Linq;
using System.Net;
using System.Threading;
using System.Xml.Linq;
using PrtgAPI.Attributes;
using PrtgAPI.Helpers;
using PrtgAPI.Objects.Deserialization;
using PrtgAPI.Parameters;

//Methods with complex logic surrounding sync/async function calls.
//For each method, two variants a generated. A synchronous method with the
//expected return type, and an async method that implicitly wraps the result
//in a Task

namespace PrtgAPI
{
    public partial class PrtgClient
    {
        //######################################
        // GetChannelsInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("GetChannelsInternal", "List<Channel>", i) #>(int sensorId, Func<string, bool> nameFilter = null)
        {
            var response = <#= CallFunction("requestEngine.ExecuteRequest", "XmlFunction.TableData, new ChannelParameters(sensorId)", i) #>;

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            if (nameFilter != null)
                items.Where(e => !nameFilter(e.Element("name").Value?.ToString())).Remove();

            items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = <#= CallFunction("GetChannelProperties", "sensorId, id", i) #>;

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorId));
            }

            if (items.Count > 0)
                return XmlDeserializer<Channel>.DeserializeList(response).Items;

            return new List<Channel>();
        }

<#
}
#>
        //######################################
        // GetNotificationActionsInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
		internal <#= GetSignature("GetNotificationActionsInternal", "List<NotificationAction>", i) #>(NotificationActionParameters parameters)
        {
            var response = <#= CallFunction("requestEngine.ExecuteRequest", "XmlFunction.TableData, parameters", i) #>;

            var items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = <#= CallFunction("GetNotificationActionProperties", "id", i) #>;

                item.Add(properties.Nodes());
            }

            return XmlDeserializer<NotificationAction>.DeserializeList(response).Items;
        }

<#
}
#>
        //######################################
        // ValidateTriggerParameters
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ValidateTriggerParameters", "void", i) #>(TriggerParameters parameters)
        {
            if (parameters.Action == ModifyAction.Add)
            {
                var data = <#= CallFunction("GetNotificationTriggerData", "parameters.ObjectId", i) #>;

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = <#= CallFunction("GetSensors", "Property.Id, parameters.ObjectId", i) #>;

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if(channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (<#= CallFunction("GetChannels", "parameters.ObjectId, ((Channel)channel.channel).Name", i) #>).Any();
                else
                    anyResponse = (<#= CallFunction("GetChannelProperties", "parameters.ObjectId, Convert.ToInt32(((IFormattable)channel).GetSerializedFormat())", i) #>).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut'"); //todo: make this dynamically get all names in the enum
            }
        }

<#
}
#>
        //######################################
        // UpdateTriggerChannels
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("UpdateTriggerChannels", "void", i) #>(List<NotificationTrigger> triggers)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.SetEnumChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}");
                    try
                    {
                        trigger.channelObj = (<#= CallFunction("GetChannelsInternal", "trigger.ObjectId, n => n == trigger.channelName", i) #>).First();
                    }
                    catch (InvalidOperationException ex)
                    {
                        if (ex.Message.Contains("Sequence contains no elements"))
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.", ex);

						throw;
                    }
                }
            }
        }

<#
}
#>
        //######################################
        // ParseNotificationTriggerTypes
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ParseNotificationTriggerTypes", "string", i) #>(HttpResponseMessage response)
        {
            var responseText = <#= AwaitOrForceResult("response.Content.ReadAsStringAsync()", i) #>

            responseText = responseText.Replace("\"data\": \"(no triggers defined)\",", "");

            return responseText;
        }

<#
}
#>
        //######################################
        // WaitForCoreRestart
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("WaitForCoreRestart", "void", i) #>(DateTime restartTime, Func<RestartCoreStage, bool> callback)
        {
            RestartCoreStage coreStage = RestartCoreStage.Shutdown;

            var originalRetries = RetryCount;

            try
            {
                RetryCount = 0;

                while (coreStage != RestartCoreStage.Completed)
                {
                    coreStage = <#= CallFunction("ProbeServer", "restartTime", i) #>;

                    if (callback != null && !callback(coreStage))
                        break;

                    if (coreStage == RestartCoreStage.Completed)
                        break;
#if !DEBUG
                    if (callback == null)
                        <#= Sleep(5000, i) #>
#endif
                }
            }
            finally
            {
                RetryCount = originalRetries;
            }
        }

<#
}
#>
        //######################################
        // ProbeServer
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ProbeServer", "RestartCoreStage", i) #>(DateTime restartTime)
        {
            RestartCoreStage coreStage;
            
            try
            {
                var logs = <#= CallFunction("GetLogs", "null, endDate: restartTime, status: LogStatus.SystemStart", i) #>;

                coreStage = logs.Any() ? RestartCoreStage.Completed : RestartCoreStage.Shutdown;
            }
            catch (Exception ex) when (ex is WebException || ex is TimeoutException)
            {
                coreStage = RestartCoreStage.Restart;
            }
            catch (HttpRequestException)
            {
                coreStage = RestartCoreStage.Startup;
            }

            return coreStage;
        }

<#
}
#>
        //######################################
        // WaitForCoreRestart
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("WaitForProbeRestart", "void", i) #>(DateTime restartTime, List<Probe> probes, Func<List<RestartProbeProgress>, bool>  progressCallback)
        {
            List<RestartProbeProgress> probeStatuses = probes.Select(p => new RestartProbeProgress(p)).ToList();

            while (probeStatuses.Any(p => p.Reconnected == false))
            {
                //Get all logs relating to probes connecting and disconnecting since we initiated the restarts.
                //If we've already detected all probes have disconnected, no need to include those logs in the response
                var statuses = new List<LogStatus> { LogStatus.Connected };

                if (probeStatuses.Any(p => !p.Disconnected))
                    statuses.Add(LogStatus.Disconnected);

                var logs = <#= CallFunction("GetLogs", "null, endDate: restartTime, status: statuses.ToArray()", i) #>;

                UpdateProbeStatus(probeStatuses, logs);

                if (progressCallback == null)
                    <#= Sleep(5000, i) #>
                else
                {
                    var result = progressCallback(probeStatuses);

                    if (!result)
                        break;
                }
            }
        }

<#
}
#>
        //######################################
        // AddObjectWithExcessiveValue
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("AddObjectWithExcessiveValue", "void", i) #>(List<KeyValuePair<Parameter, object>> lengthLimit, Parameters.Parameters internalParams, CommandFunction function)
        {
            var limitParam = lengthLimit.First();

            var limit = limitParam.Key.GetEnumAttribute<LengthLimitAttribute>().Length;

            if (limitParam.Value is IEnumerable)
            {
                var list = ((IEnumerable)limitParam.Value).Cast<object>().ToList();

                var count = list.Count();

                if (count > limit)
                {
                    for (int i = 0; i < count; i += limit)
                    {
                        var thisRequest = list.Skip(i).Take(limit);

                        internalParams[limitParam.Key] = thisRequest;

                        <#= CallFunction("requestEngine.ExecuteRequest", "function, internalParams", i) #>;
                    }
                }
                else
                    <#= CallFunction("requestEngine.ExecuteRequest", "function, internalParams", i) #>;
            }
            else
                throw new NotImplementedException($"Don't know how to handle {nameof(LengthLimitAttribute)} applied to value of type {limitParam.Value.GetType()}");
        }

<#
}
#>
        //######################################
        // ResolveSensorTargets
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("ResolveSensorTargets", "List<T>", i) #><T>(int deviceId, SensorType sensorType, Func<int, bool> progressCallback, Func<string, List<T>> parser)
        {
            var parameters = new SensorTargetParameters(deviceId, sensorType);

            <#= DeclareFunc1("getSensorTargetTmpId", "HttpResponseMessage", "string", "GetSensorTargetTmpId", i) #>;

            var tmpId = Convert.ToInt32(<#= CallFunction("requestEngine.ExecuteRequest", "CommandFunction.AddSensor2, parameters, getSensorTargetTmpId", i) #>);

            var response = <#= CallFunction("WaitForSensorTargetResolution", "deviceId, tmpId, progressCallback", i) #>;

            if (response == null)
                return null;

            return parser(response);
        }

<#
}
#>
        //######################################
        // WaitForSensorTargetResolution
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("WaitForSensorTargetResolution", "string", i) #>(int deviceId, int tmpId, Func<int, bool> progressCallback)
        {
            var parameters = new SensorTargetProgressParameters(deviceId, tmpId);

            SensorTargetProgress p;
            bool continueQuery = true;

            do
            {
                p = <#= CallGenericFunction("GetObject", "SensorTargetProgress", "JsonFunction.GetAddSensorProgress, parameters", i) #>;

                if(progressCallback != null)
                    continueQuery = progressCallback(p.Percent);

                if (p.Percent < 100)
                {
                    if (!continueQuery)
                        break;

#if !DEBUG
                    <#= Sleep(1000, i) #>
#endif
                }
            } while (p.Percent < 100);

            if (!continueQuery)
                return null;

            ValidateSensorTargetProgressResult(p);

            var page = <#= CallFunction("requestEngine.ExecuteRequest", "HtmlFunction.AddSensor4, parameters", i) #>;

            return page;
        }
<#
if(i == 0)
    WriteLine("");
}
#>
    }
}
<#+
    public string GetSignature(string name, string returnType, int i)
    {
        if(i == 0)
            return $"{returnType} {name}";
        else
        {
            if(returnType == "void")
                returnType = "Task";
            else
                returnType = $"Task<{returnType}>";
        }

        return $"async {returnType} {name}Async";
    }

    public string CallFunction(string name, string parameters, int i)
    {
        if(i == 0)
            return $"{name}({parameters})";
        else
            return $"await {name}Async({parameters}).ConfigureAwait(false)";
    }

    public string CallGenericFunction(string name, string type, string parameters, int i)
    {
        if(i == 0)
            return $"{name}<{type}>({parameters})";
        else
            return $"await {name}Async<{type}>({parameters}).ConfigureAwait(false)";
    }

    public string AwaitOrForceResult(string function, int i)
    {
        if(i == 0)
            return $"{function}.Result;";
        else
            return $"await {function}.ConfigureAwait(false);";
    }

    public string Sleep(int duration, int i)
    {
        if(i == 0)
            return $"Thread.Sleep({duration});";
        else
            return $"await Task.Delay({duration}).ConfigureAwait(false);";
    }

    public string DeclareFunc1(string funcName, string args, string returnType, string function, int i)
    {
        if(i == 0)
            return $"Func<{args}, {returnType}> {funcName} = {function}";
        else
            return $"Func<{args}, Task<{returnType}>> {funcName} = o => Task.FromResult({function}(o))";

    }
#>