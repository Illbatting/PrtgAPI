/***************************************************************************************
 * This code was generated by a tool.                                                  *
 * Please do not modify this file directly - modify PrtgClient.AsyncHelpers.tt instead *
 ***************************************************************************************/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using System.Linq;
using System.Net;
using System.Threading;
using System.Xml.Linq;
using PrtgAPI.Attributes;
using PrtgAPI.Helpers;
using PrtgAPI.Objects.Deserialization;
using PrtgAPI.Objects.Shared;
using PrtgAPI.Parameters;

//Methods with complex logic surrounding sync/async function calls.
//For each method, two variants a generated. A synchronous method with the
//expected return type, and an async method that implicitly wraps the result
//in a Task

namespace PrtgAPI
{
    public partial class PrtgClient
    {
        //######################################
        // GetChannelsInternal
        //######################################

        internal List<Channel> GetChannelsInternal(int sensorId, Func<string, bool> nameFilter = null, Func<int, bool> idFilter = null)
        {
            var response = requestEngine.ExecuteRequest(XmlFunction.TableData, new ChannelParameters(sensorId));

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            if (nameFilter != null)
                items.Where(e => !nameFilter(e.Element("name").Value?.ToString())).Remove();

            if (idFilter != null)
                items.Where(e => !idFilter(Convert.ToInt32(e.Element("objid").Value.ToString()))).Remove();

            items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = GetChannelProperties(sensorId, id);

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorId));
            }

            if (items.Count > 0)
                return XmlDeserializer<Channel>.DeserializeList(response).Items;

            return new List<Channel>();
        }

        internal async Task<List<Channel>> GetChannelsInternalAsync(int sensorId, Func<string, bool> nameFilter = null, Func<int, bool> idFilter = null)
        {
            var response = await requestEngine.ExecuteRequestAsync(XmlFunction.TableData, new ChannelParameters(sensorId)).ConfigureAwait(false);

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            if (nameFilter != null)
                items.Where(e => !nameFilter(e.Element("name").Value?.ToString())).Remove();

            if (idFilter != null)
                items.Where(e => !idFilter(Convert.ToInt32(e.Element("objid").Value.ToString()))).Remove();

            items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = await GetChannelPropertiesAsync(sensorId, id).ConfigureAwait(false);

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorId));
            }

            if (items.Count > 0)
                return XmlDeserializer<Channel>.DeserializeList(response).Items;

            return new List<Channel>();
        }

        //######################################
        // GetNotificationActionsInternal
        //######################################

        internal List<NotificationAction> GetNotificationActionsInternal(NotificationActionParameters parameters)
        {
            var response = requestEngine.ExecuteRequest(XmlFunction.TableData, parameters);

            var items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = GetNotificationActionProperties(id);

                item.Add(properties.Nodes());
            }

            return XmlDeserializer<NotificationAction>.DeserializeList(response).Items;
        }

        internal async Task<List<NotificationAction>> GetNotificationActionsInternalAsync(NotificationActionParameters parameters)
        {
            var response = await requestEngine.ExecuteRequestAsync(XmlFunction.TableData, parameters).ConfigureAwait(false);

            var items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = await GetNotificationActionPropertiesAsync(id).ConfigureAwait(false);

                item.Add(properties.Nodes());
            }

            return XmlDeserializer<NotificationAction>.DeserializeList(response).Items;
        }

        //######################################
        // ValidateTriggerParameters
        //######################################

        private void ValidateTriggerParameters(TriggerParameters parameters)
        {
            if (parameters.Action == ModifyAction.Add)
            {
                var data = GetNotificationTriggerData(parameters.ObjectId);

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = GetSensors(Property.Id, parameters.ObjectId);

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if(channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (GetChannels(parameters.ObjectId, ((Channel)channel.channel).Name)).Any();
                else
                    anyResponse = (GetChannelProperties(parameters.ObjectId, Convert.ToInt32(((IFormattable)channel).GetSerializedFormat()))).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut'"); //todo: make this dynamically get all names in the enum
            }
        }

        private async Task ValidateTriggerParametersAsync(TriggerParameters parameters)
        {
            if (parameters.Action == ModifyAction.Add)
            {
                var data = await GetNotificationTriggerDataAsync(parameters.ObjectId).ConfigureAwait(false);

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = await GetSensorsAsync(Property.Id, parameters.ObjectId).ConfigureAwait(false);

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if(channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (await GetChannelsAsync(parameters.ObjectId, ((Channel)channel.channel).Name).ConfigureAwait(false)).Any();
                else
                    anyResponse = (await GetChannelPropertiesAsync(parameters.ObjectId, Convert.ToInt32(((IFormattable)channel).GetSerializedFormat())).ConfigureAwait(false)).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut'"); //todo: make this dynamically get all names in the enum
            }
        }

        //######################################
        // UpdateTriggerChannels
        //######################################

        private void UpdateTriggerChannels(List<NotificationTrigger> triggers)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.SetEnumChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}");
                    try
                    {
                        trigger.channelObj = (GetChannelsInternal(trigger.ObjectId, n => n == trigger.channelName)).First();
                    }
                    catch (InvalidOperationException ex)
                    {
                        if (ex.Message.Contains("Sequence contains no elements"))
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.", ex);

                        throw;
                    }
                }
            }
        }

        private async Task UpdateTriggerChannelsAsync(List<NotificationTrigger> triggers)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.SetEnumChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}");
                    try
                    {
                        trigger.channelObj = (await GetChannelsInternalAsync(trigger.ObjectId, n => n == trigger.channelName).ConfigureAwait(false)).First();
                    }
                    catch (InvalidOperationException ex)
                    {
                        if (ex.Message.Contains("Sequence contains no elements"))
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.", ex);

                        throw;
                    }
                }
            }
        }

        //######################################
        // ParseNotificationTriggerTypes
        //######################################

        private string ParseNotificationTriggerTypes(HttpResponseMessage response)
        {
            var responseText = response.Content.ReadAsStringAsync().Result;

            responseText = responseText.Replace("\"data\": \"(no triggers defined)\",", "");

            return responseText;
        }

        private async Task<string> ParseNotificationTriggerTypesAsync(HttpResponseMessage response)
        {
            var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);

            responseText = responseText.Replace("\"data\": \"(no triggers defined)\",", "");

            return responseText;
        }

        //######################################
        // WaitForCoreRestart
        //######################################

        internal void WaitForCoreRestart(DateTime restartTime, Func<RestartCoreStage, bool> callback)
        {
            RestartCoreStage coreStage = RestartCoreStage.Shutdown;

            var originalRetries = RetryCount;

            try
            {
                RetryCount = 0;

                while (coreStage != RestartCoreStage.Completed)
                {
                    coreStage = ProbeServer(restartTime);

                    if (callback != null && !callback(coreStage))
                        break;

                    if (coreStage == RestartCoreStage.Completed)
                        break;
#if !DEBUG
                    if (callback == null)
                        Thread.Sleep(5000);
#endif
                }
            }
            finally
            {
                RetryCount = originalRetries;
            }
        }

        internal async Task WaitForCoreRestartAsync(DateTime restartTime, Func<RestartCoreStage, bool> callback)
        {
            RestartCoreStage coreStage = RestartCoreStage.Shutdown;

            var originalRetries = RetryCount;

            try
            {
                RetryCount = 0;

                while (coreStage != RestartCoreStage.Completed)
                {
                    coreStage = await ProbeServerAsync(restartTime).ConfigureAwait(false);

                    if (callback != null && !callback(coreStage))
                        break;

                    if (coreStage == RestartCoreStage.Completed)
                        break;
#if !DEBUG
                    if (callback == null)
                        await Task.Delay(5000).ConfigureAwait(false);
#endif
                }
            }
            finally
            {
                RetryCount = originalRetries;
            }
        }

        //######################################
        // ProbeServer
        //######################################

        private RestartCoreStage ProbeServer(DateTime restartTime)
        {
            RestartCoreStage coreStage;
            
            try
            {
                var logs = GetLogs(null, endDate: restartTime, status: LogStatus.SystemStart);

                coreStage = logs.Any() ? RestartCoreStage.Completed : RestartCoreStage.Shutdown;
            }
            catch (Exception ex) when (ex is WebException || ex is TimeoutException)
            {
                coreStage = RestartCoreStage.Restart;
            }
            catch (HttpRequestException)
            {
                coreStage = RestartCoreStage.Startup;
            }

            return coreStage;
        }

        private async Task<RestartCoreStage> ProbeServerAsync(DateTime restartTime)
        {
            RestartCoreStage coreStage;
            
            try
            {
                var logs = await GetLogsAsync(null, endDate: restartTime, status: LogStatus.SystemStart).ConfigureAwait(false);

                coreStage = logs.Any() ? RestartCoreStage.Completed : RestartCoreStage.Shutdown;
            }
            catch (Exception ex) when (ex is WebException || ex is TimeoutException)
            {
                coreStage = RestartCoreStage.Restart;
            }
            catch (HttpRequestException)
            {
                coreStage = RestartCoreStage.Startup;
            }

            return coreStage;
        }

        //######################################
        // WaitForCoreRestart
        //######################################

        internal void WaitForProbeRestart(DateTime restartTime, List<Probe> probes, Func<List<RestartProbeProgress>, bool>  progressCallback)
        {
            List<RestartProbeProgress> probeStatuses = probes.Select(p => new RestartProbeProgress(p)).ToList();

            while (probeStatuses.Any(p => p.Reconnected == false))
            {
                //Get all logs relating to probes connecting and disconnecting since we initiated the restarts.
                //If we've already detected all probes have disconnected, no need to include those logs in the response
                var statuses = new List<LogStatus> { LogStatus.Connected };

                if (probeStatuses.Any(p => !p.Disconnected))
                    statuses.Add(LogStatus.Disconnected);

                var logs = GetLogs(null, endDate: restartTime, status: statuses.ToArray());

                UpdateProbeStatus(probeStatuses, logs);

                if (progressCallback == null)
                    Thread.Sleep(5000);
                else
                {
                    var result = progressCallback(probeStatuses);

                    if (!result)
                        break;
                }
            }
        }

        internal async Task WaitForProbeRestartAsync(DateTime restartTime, List<Probe> probes, Func<List<RestartProbeProgress>, bool>  progressCallback)
        {
            List<RestartProbeProgress> probeStatuses = probes.Select(p => new RestartProbeProgress(p)).ToList();

            while (probeStatuses.Any(p => p.Reconnected == false))
            {
                //Get all logs relating to probes connecting and disconnecting since we initiated the restarts.
                //If we've already detected all probes have disconnected, no need to include those logs in the response
                var statuses = new List<LogStatus> { LogStatus.Connected };

                if (probeStatuses.Any(p => !p.Disconnected))
                    statuses.Add(LogStatus.Disconnected);

                var logs = await GetLogsAsync(null, endDate: restartTime, status: statuses.ToArray()).ConfigureAwait(false);

                UpdateProbeStatus(probeStatuses, logs);

                if (progressCallback == null)
                    await Task.Delay(5000).ConfigureAwait(false);
                else
                {
                    var result = progressCallback(probeStatuses);

                    if (!result)
                        break;
                }
            }
        }

        //######################################
        // AddObjectWithExcessiveValue
        //######################################

        private void AddObjectWithExcessiveValue(List<KeyValuePair<Parameter, object>> lengthLimit, Parameters.Parameters internalParams, CommandFunction function)
        {
            var limitParam = lengthLimit.First();

            var limit = limitParam.Key.GetEnumAttribute<LengthLimitAttribute>().Length;

            if (limitParam.Value is IEnumerable)
            {
                var list = ((IEnumerable)limitParam.Value).Cast<object>().ToList();

                var count = list.Count();

                if (count > limit)
                {
                    for (int i = 0; i < count; i += limit)
                    {
                        var thisRequest = list.Skip(i).Take(limit);

                        internalParams[limitParam.Key] = thisRequest;

                        requestEngine.ExecuteRequest(function, internalParams);
                    }
                }
                else
                    requestEngine.ExecuteRequest(function, internalParams);
            }
            else
                throw new NotImplementedException($"Don't know how to handle {nameof(LengthLimitAttribute)} applied to value of type {limitParam.Value.GetType()}");
        }

        private async Task AddObjectWithExcessiveValueAsync(List<KeyValuePair<Parameter, object>> lengthLimit, Parameters.Parameters internalParams, CommandFunction function)
        {
            var limitParam = lengthLimit.First();

            var limit = limitParam.Key.GetEnumAttribute<LengthLimitAttribute>().Length;

            if (limitParam.Value is IEnumerable)
            {
                var list = ((IEnumerable)limitParam.Value).Cast<object>().ToList();

                var count = list.Count();

                if (count > limit)
                {
                    for (int i = 0; i < count; i += limit)
                    {
                        var thisRequest = list.Skip(i).Take(limit);

                        internalParams[limitParam.Key] = thisRequest;

                        await requestEngine.ExecuteRequestAsync(function, internalParams).ConfigureAwait(false);
                    }
                }
                else
                    await requestEngine.ExecuteRequestAsync(function, internalParams).ConfigureAwait(false);
            }
            else
                throw new NotImplementedException($"Don't know how to handle {nameof(LengthLimitAttribute)} applied to value of type {limitParam.Value.GetType()}");
        }

        //######################################
        // ResolveSensorTargets
        //######################################

        internal List<T> ResolveSensorTargets<T>(int deviceId, SensorType sensorType, Func<int, bool> progressCallback, Func<string, List<T>> parser)
        {
            var parameters = new SensorTargetParameters(deviceId, sensorType);

            Func<HttpResponseMessage, string> getSensorTargetTmpId = GetSensorTargetTmpId;

            var tmpId = Convert.ToInt32(requestEngine.ExecuteRequest(CommandFunction.AddSensor2, parameters, getSensorTargetTmpId));

            var response = WaitForSensorTargetResolution(deviceId, tmpId, progressCallback);

            if (response == null)
                return null;

            return parser(response);
        }

        internal async Task<List<T>> ResolveSensorTargetsAsync<T>(int deviceId, SensorType sensorType, Func<int, bool> progressCallback, Func<string, List<T>> parser)
        {
            var parameters = new SensorTargetParameters(deviceId, sensorType);

            Func<HttpResponseMessage, Task<string>> getSensorTargetTmpId = o => Task.FromResult(GetSensorTargetTmpId(o));

            var tmpId = Convert.ToInt32(await requestEngine.ExecuteRequestAsync(CommandFunction.AddSensor2, parameters, getSensorTargetTmpId).ConfigureAwait(false));

            var response = await WaitForSensorTargetResolutionAsync(deviceId, tmpId, progressCallback).ConfigureAwait(false);

            if (response == null)
                return null;

            return parser(response);
        }

        //######################################
        // WaitForSensorTargetResolution
        //######################################

        private string WaitForSensorTargetResolution(int deviceId, int tmpId, Func<int, bool> progressCallback)
        {
            var parameters = new SensorTargetProgressParameters(deviceId, tmpId);

            SensorTargetProgress p;
            bool continueQuery = true;

            do
            {
                p = GetObject<SensorTargetProgress>(JsonFunction.GetAddSensorProgress, parameters);

                if(progressCallback != null)
                    continueQuery = progressCallback(p.Percent);

                if (p.Percent < 100)
                {
                    if (!continueQuery)
                        break;

#if !DEBUG
                    Thread.Sleep(1000);
#endif
                }
            } while (p.Percent < 100);

            if (!continueQuery)
                return null;

            ValidateSensorTargetProgressResult(p);

            var page = requestEngine.ExecuteRequest(HtmlFunction.AddSensor4, parameters);

            return page;
        }
        private async Task<string> WaitForSensorTargetResolutionAsync(int deviceId, int tmpId, Func<int, bool> progressCallback)
        {
            var parameters = new SensorTargetProgressParameters(deviceId, tmpId);

            SensorTargetProgress p;
            bool continueQuery = true;

            do
            {
                p = await GetObjectAsync<SensorTargetProgress>(JsonFunction.GetAddSensorProgress, parameters).ConfigureAwait(false);

                if(progressCallback != null)
                    continueQuery = progressCallback(p.Percent);

                if (p.Percent < 100)
                {
                    if (!continueQuery)
                        break;

#if !DEBUG
                    await Task.Delay(1000).ConfigureAwait(false);
#endif
                }
            } while (p.Percent < 100);

            if (!continueQuery)
                return null;

            ValidateSensorTargetProgressResult(p);

            var page = await requestEngine.ExecuteRequestAsync(HtmlFunction.AddSensor4, parameters).ConfigureAwait(false);

            return page;
        }
        //######################################
        // AddObject
        //######################################

        internal List<T> AddObject<T>(int parentId, NewObjectParameters parameters, CommandFunction function,
            Func<SearchFilter[], List<T>> getObjects, bool resolve, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null,
            bool allowMultiple = false) where T : SensorOrDeviceOrGroupOrProbe
        {
            if (resolve)
            {
                var filters = GetFilters(parentId, parameters);

                Action addObjectInternal = () => AddObjectInternal(parentId, parameters, function);
                Func<List<T>> getObjs = () => getObjects(filters);

                return (ResolveWithDiff(addObjectInternal, getObjs, ExceptTableObject, errorCallback, shouldStop, allowMultiple)).OrderBy(o => o.Id).ToList();
            }
            else
            {
                AddObjectInternal(parentId, parameters, function);

                return null;
            }
        }

        private void AddObjectInternal(int objectId, NewObjectParameters parameters, CommandFunction function)
        {
            var lengthLimit = ValidateObjectParameters(parameters);

            var internalParams = GetInternalNewObjectParameters(objectId, parameters);

            if (lengthLimit.Count > 0)
                AddObjectWithExcessiveValue(lengthLimit, internalParams, function);
            else
                requestEngine.ExecuteRequest(function, internalParams);
        }

        private List<T> ResolveWithDiff<T>(Action createObject, Func<List<T>> getObjects, Func<List<T>, List<T>, List<T>> exceptFunc,
            Action<Type, int> errorCallback, Func<bool> shouldStop, bool allowMultiple = false)
        {
            var before = getObjects();

            createObject();

            var after = ResolveObject(getObjects, a => exceptFunc(before, a).Any(), errorCallback: errorCallback, shouldStop: shouldStop);

            var newObjects = exceptFunc(before, after);

            if(!allowMultiple && newObjects.Count > 1)
            {
                var typeName = typeof (T).Name;

                IEnumerable<string> names;

                if (typeof (PrtgObject).IsAssignableFrom(typeof (T)))
                {
                    var objs = newObjects.Cast<PrtgObject>();

                    names = objs.Select(o => $"'{o.Name}' (ID: {o.Id})");
                }
                else
                    names = newObjects.Select(o => $"'{o}'");

                var str = $"Could not uniquely identify created {typeName}: multiple new objects ({string.Join(", ", names)}) were found under parent object. Did you create an additional object with the same type or name under the parent while resolution was occurring?";

                throw new ObjectResolutionException(str);
            }

            return CleanObjects(newObjects);
        }

        internal List<T> ResolveObject<T>(Func< List<T>> getObjects, Func<List<T>, bool> recordsFound, string resolutionError = "Could not resolve object",
            Type trueType = null, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            List<T> @object;

            var retriesRemaining = 4;
            var delay = 3;

            do
            {
                @object = getObjects();

                if (!recordsFound(@object))
                {
                    if (retriesRemaining == 0)
                    {
                        throw new ObjectResolutionException($"{resolutionError}: PRTG is taking too long to create the object. Confirm the object has been created in the Web UI and then attempt resolution again manually");
                    }

                    var type = trueType ?? typeof (T);

                    errorCallback?.Invoke(type, retriesRemaining);
                    retriesRemaining--;

#if DEBUG
                    if (!UnitTest())
#endif
                        Thread.Sleep(delay * 1000);

                    delay *= 2;
                }

                if (shouldStop?.Invoke() == true)
                    break;

            } while (!recordsFound(@object));

            return @object;
        }
        
        private List<T> CleanObjects<T>(List<T> newObjects)
        {
            if (newObjects.All(o => o is Sensor))
            {
                var sensors = newObjects.Cast<Sensor>().ToList();

                bool modified = false;

                foreach (var obj in sensors)
                {
                    //PRTG may sometimes prepend spaces to the front of the sensor name. This can even happen
                    //in the Web UI
                    if (obj.Name != obj.Name.Trim(' '))
                    {
                        modified = true;
                        RenameObject(obj.Id, obj.Name.Trim(' '));
                    }
                }

                if(modified)
                    newObjects = (GetSensors(Property.Id, sensors.Select(s => s.Id))).Cast<T>().ToList();
            }

            return newObjects;
        }

        internal async Task<List<T>> AddObjectAsync<T>(int parentId, NewObjectParameters parameters, CommandFunction function,
            Func<SearchFilter[], Task<List<T>>> getObjects, bool resolve, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null,
            bool allowMultiple = false) where T : SensorOrDeviceOrGroupOrProbe
        {
            if (resolve)
            {
                var filters = GetFilters(parentId, parameters);

                Func<Task> addObjectInternal = async () => await AddObjectInternalAsync(parentId, parameters, function).ConfigureAwait(false);
                Func<Task<List<T>>> getObjs = async () => await getObjects(filters).ConfigureAwait(false);

                return (await ResolveWithDiffAsync(addObjectInternal, getObjs, ExceptTableObject, errorCallback, shouldStop, allowMultiple).ConfigureAwait(false)).OrderBy(o => o.Id).ToList();
            }
            else
            {
                await AddObjectInternalAsync(parentId, parameters, function).ConfigureAwait(false);

                return null;
            }
        }

        private async Task AddObjectInternalAsync(int objectId, NewObjectParameters parameters, CommandFunction function)
        {
            var lengthLimit = ValidateObjectParameters(parameters);

            var internalParams = GetInternalNewObjectParameters(objectId, parameters);

            if (lengthLimit.Count > 0)
                await AddObjectWithExcessiveValueAsync(lengthLimit, internalParams, function).ConfigureAwait(false);
            else
                await requestEngine.ExecuteRequestAsync(function, internalParams).ConfigureAwait(false);
        }

        private async Task<List<T>> ResolveWithDiffAsync<T>(Func<Task> createObject, Func<Task<List<T>>> getObjects, Func<List<T>, List<T>, List<T>> exceptFunc,
            Action<Type, int> errorCallback, Func<bool> shouldStop, bool allowMultiple = false)
        {
            var before = await getObjects().ConfigureAwait(false);

            await createObject().ConfigureAwait(false);

            var after = await ResolveObjectAsync(getObjects, a => exceptFunc(before, a).Any(), errorCallback: errorCallback, shouldStop: shouldStop).ConfigureAwait(false);

            var newObjects = exceptFunc(before, after);

            if(!allowMultiple && newObjects.Count > 1)
            {
                var typeName = typeof (T).Name;

                IEnumerable<string> names;

                if (typeof (PrtgObject).IsAssignableFrom(typeof (T)))
                {
                    var objs = newObjects.Cast<PrtgObject>();

                    names = objs.Select(o => $"'{o.Name}' (ID: {o.Id})");
                }
                else
                    names = newObjects.Select(o => $"'{o}'");

                var str = $"Could not uniquely identify created {typeName}: multiple new objects ({string.Join(", ", names)}) were found under parent object. Did you create an additional object with the same type or name under the parent while resolution was occurring?";

                throw new ObjectResolutionException(str);
            }

            return await CleanObjectsAsync(newObjects).ConfigureAwait(false);
        }

        internal async Task<List<T>> ResolveObjectAsync<T>(Func< Task<List<T>>> getObjects, Func<List<T>, bool> recordsFound, string resolutionError = "Could not resolve object",
            Type trueType = null, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            List<T> @object;

            var retriesRemaining = 4;
            var delay = 3;

            do
            {
                @object = await getObjects().ConfigureAwait(false);

                if (!recordsFound(@object))
                {
                    if (retriesRemaining == 0)
                    {
                        throw new ObjectResolutionException($"{resolutionError}: PRTG is taking too long to create the object. Confirm the object has been created in the Web UI and then attempt resolution again manually");
                    }

                    var type = trueType ?? typeof (T);

                    errorCallback?.Invoke(type, retriesRemaining);
                    retriesRemaining--;

#if DEBUG
                    if (!UnitTest())
#endif
                        await Task.Delay(delay * 1000).ConfigureAwait(false);

                    delay *= 2;
                }

                if (shouldStop?.Invoke() == true)
                    break;

            } while (!recordsFound(@object));

            return @object;
        }
        
        private async Task<List<T>> CleanObjectsAsync<T>(List<T> newObjects)
        {
            if (newObjects.All(o => o is Sensor))
            {
                var sensors = newObjects.Cast<Sensor>().ToList();

                bool modified = false;

                foreach (var obj in sensors)
                {
                    //PRTG may sometimes prepend spaces to the front of the sensor name. This can even happen
                    //in the Web UI
                    if (obj.Name != obj.Name.Trim(' '))
                    {
                        modified = true;
                        await RenameObjectAsync(obj.Id, obj.Name.Trim(' ')).ConfigureAwait(false);
                    }
                }

                if(modified)
                    newObjects = (await GetSensorsAsync(Property.Id, sensors.Select(s => s.Id)).ConfigureAwait(false)).Cast<T>().ToList();
            }

            return newObjects;
        }

        //######################################
        // AddNotificationTriggerInternal
        //######################################

        internal List<NotificationTrigger> AddNotificationTriggerInternal(TriggerParameters parameters, bool resolve,
            Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            if (resolve)
            {
                Action addTrigger = () => SetNotificationTrigger(parameters);
                Func<List<NotificationTrigger>> getTrigger = () => GetNotificationTriggers(parameters.ObjectId).Where(t => !t.Inherited).ToList();

                var objs = ResolveWithDiff(addTrigger, getTrigger, (b,a) => ExceptTrigger(b, a, parameters), errorCallback, shouldStop);

                return objs;
            }
            else
            {
                SetNotificationTrigger(parameters);

                return null;
            }
        }

        internal async Task<List<NotificationTrigger>> AddNotificationTriggerInternalAsync(TriggerParameters parameters, bool resolve,
            Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            if (resolve)
            {
                Func<Task> addTrigger = async () => await SetNotificationTriggerAsync(parameters).ConfigureAwait(false);
                Func<Task<List<NotificationTrigger>>> getTrigger = async () => (await GetNotificationTriggersAsync(parameters.ObjectId).ConfigureAwait(false)).Where(t => !t.Inherited).ToList();

                var objs = await ResolveWithDiffAsync(addTrigger, getTrigger, (b,a) => ExceptTrigger(b, a, parameters), errorCallback, shouldStop).ConfigureAwait(false);

                return objs;
            }
            else
            {
                SetNotificationTrigger(parameters);

                return null;
            }
        }
    }
}
