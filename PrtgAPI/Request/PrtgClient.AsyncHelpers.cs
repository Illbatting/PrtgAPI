/***************************************************************************************
 * This code was generated by a tool.                                                  *
 * Please do not modify this file directly - modify PrtgClient.AsyncHelpers.tt instead *
 ***************************************************************************************/
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using System.Linq;
using System.Xml.Linq;
using PrtgAPI.Objects.Deserialization;
using PrtgAPI.Parameters;

//Methods with complex logic surrounding sync/async function calls.
//For each method, two variants a generated. A synchronous method with the
//expected return type, and an async method that implicitly wraps the result
//in a Task

namespace PrtgAPI
{
    public partial class PrtgClient
    {
        //######################################
        // GetChannelsInternal
        //######################################

        internal List<Channel> GetChannelsInternal(int sensorId, Func<string, bool> nameFilter = null)
        {
            var response = requestEngine.ExecuteRequest(XmlFunction.TableData, new ChannelParameters(sensorId));

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            if (nameFilter != null)
                items.Where(e => !nameFilter(e.Element("name").Value?.ToString())).Remove();

            items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = GetChannelProperties(sensorId, id);

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorId));
            }

            if (items.Count > 0)
                return Data<Channel>.DeserializeList(response).Items;

            return new List<Channel>();
        }

        internal async Task<List<Channel>> GetChannelsInternalAsync(int sensorId, Func<string, bool> nameFilter = null)
        {
            var response = await requestEngine.ExecuteRequestAsync(XmlFunction.TableData, new ChannelParameters(sensorId)).ConfigureAwait(false);

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            if (nameFilter != null)
                items.Where(e => !nameFilter(e.Element("name").Value?.ToString())).Remove();

            items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = await GetChannelPropertiesAsync(sensorId, id).ConfigureAwait(false);

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorId));
            }

            if (items.Count > 0)
                return Data<Channel>.DeserializeList(response).Items;

            return new List<Channel>();
        }

        //######################################
        // ValidateTriggerParameters
        //######################################

        private void ValidateTriggerParameters(TriggerParameters parameters)
        {
            if (parameters.Action == ModifyAction.Add)
            {
                var data = GetNotificationTriggerData(parameters.ObjectId);

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = GetSensors(Property.Id, parameters.ObjectId);

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if(channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (GetChannels(parameters.ObjectId, ((Channel)channel.channel).Name)).Any();
                else
                    anyResponse = (GetChannelProperties(parameters.ObjectId, Convert.ToInt32(((IFormattable)channel).GetSerializedFormat()))).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut'"); //todo: make this dynamically get all names in the enum
            }
        }

        private async Task ValidateTriggerParametersAsync(TriggerParameters parameters)
        {
            if (parameters.Action == ModifyAction.Add)
            {
                var data = await GetNotificationTriggerDataAsync(parameters.ObjectId).ConfigureAwait(false);

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = await GetSensorsAsync(Property.Id, parameters.ObjectId).ConfigureAwait(false);

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if(channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (await GetChannelsAsync(parameters.ObjectId, ((Channel)channel.channel).Name).ConfigureAwait(false)).Any();
                else
                    anyResponse = (await GetChannelPropertiesAsync(parameters.ObjectId, Convert.ToInt32(((IFormattable)channel).GetSerializedFormat())).ConfigureAwait(false)).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut'"); //todo: make this dynamically get all names in the enum
            }
        }

        //######################################
        // UpdateTriggerChannels
        //######################################

        private void UpdateTriggerChannels(List<NotificationTrigger> triggers)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.SetEnumChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}");
                    try
                    {
                        trigger.channelObj = (GetChannelsInternal(trigger.ObjectId, n => n == trigger.channelName)).First();
                    }
                    catch (InvalidOperationException ex)
                    {
                        if (ex.Message.Contains("Sequence contains no elements"))
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.", ex);
                    }
                }
            }
        }
        private async Task UpdateTriggerChannelsAsync(List<NotificationTrigger> triggers)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.SetEnumChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}");
                    try
                    {
                        trigger.channelObj = (await GetChannelsInternalAsync(trigger.ObjectId, n => n == trigger.channelName).ConfigureAwait(false)).First();
                    }
                    catch (InvalidOperationException ex)
                    {
                        if (ex.Message.Contains("Sequence contains no elements"))
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.", ex);
                    }
                }
            }
        }
        //######################################
        // ParseNotificationTriggerTypes
        //######################################

        private string ParseNotificationTriggerTypes(HttpResponseMessage response)
        {
            var responseText = response.Content.ReadAsStringAsync().Result;

            responseText = responseText.Replace("\"data\": \"(no triggers defined)\",", "");

            return responseText;
        }

        private async Task<string> ParseNotificationTriggerTypesAsync(HttpResponseMessage response)
        {
            var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);

            responseText = responseText.Replace("\"data\": \"(no triggers defined)\",", "");

            return responseText;
        }
    }
}

