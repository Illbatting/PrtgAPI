<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="T4Functions.ttinc" #>
<#@ output extension=".cs" #>
/************************************************************************************
 * This code was generated by a tool.                                               *
 * Please do not modify this file directly - modify PrtgClient.Generated.tt instead *
 ************************************************************************************/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using PrtgAPI.Attributes;
using PrtgAPI.Helpers;
using PrtgAPI.Parameters;
using PrtgAPI.Linq;
using PrtgAPI.Request.Serialization;
using PrtgAPI.Request;
using PrtgAPI.Targets;

//Methods with complex logic surrounding sync/async function calls.
//For each method, two variants a generated. A synchronous method with the
//expected return type, and an async method that implicitly wraps the result
//in a Task

namespace PrtgAPI
{
    public partial class PrtgClient
    {
        //######################################
        // GetChannelsInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("GetChannelsInternal", "List<Channel>", i) #>(int sensorId, Func<string, bool> nameFilter = null, Func<int, bool> idFilter = null, CancellationToken token = default(CancellationToken))
        {
            if (nameFilter == null)
                nameFilter = n => true;

            if (idFilter == null)
                idFilter = i => true;

            var response = <#= CallFunction("RequestEngine.ExecuteRequest", "new ChannelParameters(sensorId), token: token", i) #>;

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            items.Where(e => 
                !nameFilter(e.Element("name").Value?.ToString()) ||
                !idFilter(Convert.ToInt32(e.Element("objid").Value.ToString()))
            ).Remove();

            items = response.Descendants("item").ToList();

            <#= StartLoopOrTask("item", "items", i) #>
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = <#= CallFunction("GetChannelProperties", "sensorId, id, token", i) #>;

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorId));
            }<#= EndLoopOrTask(i) #>

            if (items.Count > 0)
                return XmlDeserializer<Channel>.DeserializeList(response).Items;

            return new List<Channel>();
        }

<#
}
#>
        //######################################
        // GetNotificationActionsInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("GetNotificationActionsInternal", "List<NotificationAction>", i) #>(NotificationActionParameters parameters, CancellationToken token)
        {
            var response = <#= CallFunction("RequestEngine.ExecuteRequest", "parameters, token: token", i) #>;

            var items = response.Descendants("item").ToList();

            <#= StartLoopOrTask("item", "items", i) #>
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = <#= CallFunction("GetNotificationActionProperties", "id, token", i) #>;

                item.Add(properties.Nodes());
            }<#= EndLoopOrTask(i) #>

            var actions = XmlDeserializer<NotificationAction>.DeserializeList(response).Items;

            var actionsWithSchedules = ResponseParser.GroupActionSchedules(actions).ToList();

            <#= CallFunction("UpdateActionSchedules", "actionsWithSchedules, token", i) #>;

            return actions;
        }

<#
}
#>
        //######################################
        // GetSchedulesInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("GetSchedulesInternal", "List<Schedule>", i) #>(ScheduleParameters parameters, CancellationToken token)
        {
            var schedules = <#= CallGenericFunction("ObjectEngine.GetObjects", "Schedule", "parameters, token: token", i) #>;

            <#= StartLoopOrTask("schedule", "schedules", i) #>
            {
                var response = <#= CallFunction("GetObjectPropertiesRawInternal", "schedule.Id, ObjectType.Schedule, token", i) #>;
                ResponseParser.LoadTimeTable(schedule, response);
            }<#= EndLoopOrTask(i) #>

            return schedules;
        }

<#
}
#>
        //######################################
        // ValidateTriggerParameters
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ValidateTriggerParameters", "void", i) #>(TriggerParameters parameters, CancellationToken token)
        {
            if (parameters.Action == ModifyAction.Add)
            {
                var data = <#= CallFunction("GetNotificationTriggerData", "parameters.ObjectId, token", i) #>;

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = RequestParser.GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = <#= CallFunction("GetSensors", "Property.Id, parameters.ObjectId, token", i) #>;

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if(channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (<#= CallFunction("GetChannelsInternal", "parameters.ObjectId, n => n == ((Channel)channel.channel).Name, i => i == ((Channel)channel.channel).Id, token", i) #>).Any();
                else
                    anyResponse = (<#= CallFunction("GetChannelProperties", "parameters.ObjectId, Convert.ToInt32(((ISerializable)channel).GetSerializedFormat()), token", i) #>).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel {(channel.channel is int ? "ID " : "")}'{channel}' is not a valid channel for sensor with ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                {
                    var prefix = channel.channel is int ? $"Channel ID '{channel}'" : $"Channel '{channel.channel}' of type '{channel.channel.GetType().Name}'";

                    throw new InvalidOperationException($"{prefix} is not a valid channel for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut' of type '{nameof(StandardTriggerChannel)}'."); //todo: make this dynamically get all names in the enum
                }
            }
        }

<#
}
#>
        //######################################
        // UpdateTriggerChannels
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("UpdateTriggerChannels", "void", i) #>(List<NotificationTrigger> triggers, CancellationToken token)
        {
            foreach (var trigger in triggers)
            {
                if(trigger.HasChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}", LogLevel.Trace);

                    bool isSensor = false;

                    trigger.channelObj = (<#= CallFunction("GetChannelsInternal", "trigger.ObjectId, n => { isSensor = true; return n == trigger.channelName; }, token: token", i) #>).FirstOrDefault();

                    if(trigger.channelObj == null)
                    {
                        //Either we're not a sensor, or our channel is corrupt.
                        //If we detected we had ANY channels, we must be a sensor.
                        //If SetEnumChannel fails (which should be impossible)
                        //then maybe we're a sensor with zero channels or something?

                        if((isSensor && !trigger.Inherited) || !trigger.SetEnumChannel())
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.");
                    }
                }
            }
        }

<#
}
#>
        //######################################
        // ParseNotificationTriggerTypes
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ParseNotificationTriggerTypes", "string", i) #>(HttpResponseMessage response)
        {
            var responseText = <#= AwaitOrForceResult("response.Content.ReadAsStringAsync()", i) #>

            var match = Regex.Match(responseText, "\"data\": \"(.+?)\",");

            if(match.Success)
                responseText = responseText.Replace(match.Value, "");

            return responseText;
        }

<#
}
#>
        //######################################
        // WaitForCoreRestart
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("WaitForCoreRestart", "void", i) #>(DateTime restartTime, Func<RestartCoreStage, bool> callback, CancellationToken token)
        {
            RestartCoreStage coreStage = RestartCoreStage.Shutdown;

            var originalRetries = RetryCount;

            try
            {
                RetryCount = 0;

                while (coreStage != RestartCoreStage.Completed && !token.IsCancellationRequested)
                {
                    coreStage = <#= CallFunction("ProbeServer", "restartTime, token", i) #>;

                    if (callback != null && !callback(coreStage))
                        break;

                    if (coreStage == RestartCoreStage.Completed)
                        break;
#if !DEBUG
                    if (callback == null)
                        <#= WaitOne("5000", "token", i) #>
#endif
                }
            }
            finally
            {
                RetryCount = originalRetries;
            }
        }

<#
}
#>
        //######################################
        // ProbeServer
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ProbeServer", "RestartCoreStage", i) #>(DateTime restartTime, CancellationToken token)
        {
            RestartCoreStage coreStage;
            
            try
            {
                var logs = <#= CallFunction("GetLogs", "new LogParameters(null, null, restartTime, status: LogStatus.SystemStart), token", i) #>;

                coreStage = logs.Any() ? RestartCoreStage.Completed : RestartCoreStage.Shutdown;
            }
            catch (Exception ex) when (ex is WebException || ex is TimeoutException)
            {
                coreStage = RestartCoreStage.Restart;
            }
            catch (HttpRequestException)
            {
                coreStage = RestartCoreStage.Startup;
            }

            return coreStage;
        }

<#
}
#>
        //######################################
        // WaitForCoreRestart
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("WaitForProbeRestart", "void", i) #>(DateTime restartTime, List<Probe> probes, Func<ProbeRestartProgress[], bool>  progressCallback, CancellationToken token)
        {
            List<ProbeRestartProgress> probeStatuses = probes.Select(p => new ProbeRestartProgress(p)).ToList();

            while (probeStatuses.Any(p => p.Reconnected == false) && !token.IsCancellationRequested)
            {
                //Get all logs relating to probes connecting and disconnecting since we initiated the restarts.
                //If we've already detected all probes have disconnected, no need to include those logs in the response
                var statuses = new List<LogStatus> { LogStatus.Connected };

                if (probeStatuses.Any(p => !p.Disconnected))
                    statuses.Add(LogStatus.Disconnected);

                var logs = <#= CallFunction("GetLogs", "new LogParameters(null, null, restartTime, status: statuses.ToArray()), token", i) #>;

                ResponseParser.UpdateProbeStatus(probeStatuses, logs);

                if (progressCallback == null)
                    <#= WaitOne("5000", "token", i) #>
                else
                {
                    var result = progressCallback(probeStatuses.ToArray());

                    if (!result)
                        break;
                }
            }
        }

<#
}
#>
        //######################################
        // AddObjectWithExcessiveValue
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("AddObjectWithExcessiveValue", "void", i) #>(List<KeyValuePair<Parameter, object>> lengthLimit, ICommandParameters internalParams, CancellationToken token)
        {
            var limitParam = lengthLimit.First();

            var limit = limitParam.Key.GetEnumAttribute<LengthLimitAttribute>().Length;

            if (limitParam.Value.IsIEnumerable())
            {
                var list = limitParam.Value.ToIEnumerable().ToList();

                var count = list.Count();

                if (count > limit)
                {
                    for (int i = 0; i < count; i += limit)
                    {
                        var thisRequest = list.Skip(i).Take(limit);

                        internalParams[limitParam.Key] = thisRequest;

                        <#= CallFunction("RequestEngine.ExecuteRequest", "internalParams, token: token", i) #>;
                    }
                }
                else
                    <#= CallFunction("RequestEngine.ExecuteRequest", "internalParams, token: token", i) #>;
            }
            else
                throw new NotImplementedException($"Don't know how to handle {nameof(LengthLimitAttribute)} applied to value of type {limitParam.Value.GetType()}");
        }

<#
}
#>
        //######################################
        // ResolveSensorTargets
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("ResolveSensorTargets", "List<T>", i) #><T>(int deviceId, SensorType sensorType, Func<int, bool> progressCallback, CancellationToken token, Func<string, List<T>> parser)
        {
            var parameters = new SensorTargetParameters(deviceId, sensorType);

            return <#= CallFunction("ResolveSensorTargets", "deviceId, parameters, progressCallback, token, parser", i) #>;
        }

        internal <#= GetSignature("ResolveSensorTargets", "List<T>", i) #><T>(int deviceId, string sensorType, Func<int, bool> progressCallback, CancellationToken token, Func<string, List<T>> parser)
        {
            var parameters = new SensorTargetParameters(deviceId, sensorType);

            return <#= CallFunction("ResolveSensorTargets", "deviceId, parameters, progressCallback, token, parser", i) #>;
        }

        private <#= GetSignature("ResolveSensorTargets", "List<T>", i) #><T>(int deviceId, SensorTargetParameters parameters, Func<int, bool> progressCallback, CancellationToken token, Func<string, List<T>> parser)
        {
            var response = <#= CallFunction("GetSensorTargetsResponse", "deviceId, parameters, progressCallback, token", i) #>;

            if (response == null)
                return null;

            return parser(response);
        }

<#
}
#>
        //######################################
        // GetSensorTargetsResponse
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("GetSensorTargetsResponse", "string", i) #>(int deviceId, string sensorType, Func<int, bool> progressCallback, CancellationToken token)
        {
            var parameters = new SensorTargetParameters(deviceId, sensorType);

            return <#= CallFunction("GetSensorTargetsResponse", "deviceId, parameters, progressCallback, token", i) #>;
        }

        private <#= GetSignature("GetSensorTargetsResponse", "string", i) #>(int deviceId, SensorTargetParameters parameters, Func<int, bool> progressCallback, CancellationToken token)
        {
            <#= DeclareLightFunc1("getSensorTargetTmpId", "HttpResponseMessage", "string", "ResponseParser.GetSensorTargetTmpId", i) #>;

            var tmpIdStr = <#= CallFunction("RequestEngine.ExecuteRequest", "parameters, getSensorTargetTmpId, token", i) #>;

            int tmpId;

            if (!int.TryParse(tmpIdStr, out tmpId))
                throw new PrtgRequestException($"Failed to resolve sensor targets for sensor type '{parameters[Parameter.SensorType]}': type was not valid");

            var response = <#= CallFunction("WaitForSensorTargetResolution", "deviceId, tmpId, progressCallback, token", i) #>;

            return response;
        }

<#
}
#>
        //######################################
        // WaitForSensorTargetResolution
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("WaitForSensorTargetResolution", "string", i) #>(int deviceId, int tmpId, Func<int, bool> progressCallback, CancellationToken token)
        {
            var parameters = new SensorTargetProgressParameters(deviceId, tmpId);

            SensorTargetProgress p;
            bool continueQuery = true;

            var stopwatch = new Stopwatch();
            var timeout = TimeSpan.FromSeconds(60);

            stopwatch.Start();

            do
            {
                p = <#= CallGenericFunction("ObjectEngine.GetObject", "SensorTargetProgress", "parameters, token: token", i) #>;

                if(progressCallback != null)
                    continueQuery = progressCallback(p.Percent);

                if (p.Percent < 100)
                {
                    if (!continueQuery)
                        break;

                        if (stopwatch.Elapsed > timeout)
                            throw new TimeoutException("Failed to retrieve sensor information within a reasonable period of time. Check target device is accessible and that valid credentials have been supplied");

#if !DEBUG
                    <#= WaitOne("1000", "token", i) #>
#endif
                }
            } while (p.Percent < 100);

            if (!continueQuery)
                return null;

            ResponseParser.ValidateSensorTargetProgressResult(p);

            var page = <#= CallFunction("RequestEngine.ExecuteRequest", "new SensorTargetCompletedParameters(deviceId, tmpId), token: token", i) #>;

            return page;
        }

<#
}
#>
        //######################################
        // AddObject
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("AddObject", "List<T>", i) #><T>(int parentId, NewObjectParameters parameters,
            Func<SearchFilter[], CancellationToken, <#= GetFuncRet("List<T>", i) #>> getObjects, bool resolve, CancellationToken token, Action<Type, int> errorCallback = null,
            Func<bool> shouldStop = null, bool allowMultiple = false) where T : SensorOrDeviceOrGroupOrProbe
        {
            if (resolve)
            {
                var filters = RequestParser.GetFilters(parentId, parameters);

                <#= DeclareTokenAction0("addObjectInternal", "AddObjectInternal", "parentId, parameters", i) #>;
                <#= DeclareTokenFuncFromVariable0("getObjs", "getObjects", "filters", "List<T>", i) #>;

                return (<#= CallFunction("ResolveWithDiff", "addObjectInternal, getObjs, ResponseParser.ExceptTableObject, token, errorCallback, shouldStop, allowMultiple", i) #>).OrderBy(o => o.Id).ToList();
            }
            else
            {
                <#= CallFunction("AddObjectInternal", "parentId, parameters, token", i) #>;

                return null;
            }
        }

        private <#= GetSignature("AddObjectInternal", "void", i) #>(int objectId, NewObjectParameters parameters, CancellationToken token)
        {
            var lengthLimit = RequestParser.ValidateObjectParameters(parameters);

            var internalParams = RequestParser.GetInternalNewObjectParameters(objectId, parameters);

            if (lengthLimit.Count > 0)
                <#= CallFunction("AddObjectWithExcessiveValue", "lengthLimit, internalParams, token", i) #>;
            else
                <#= CallFunction("RequestEngine.ExecuteRequest", "internalParams, token: token", i) #>;
        }

        private <#= GetSignature("ResolveWithDiff", "List<T>", i) #><T>(<#= GetTokenActionParam0(i) #> createObject, Func<CancellationToken, <#= GetFuncRet("List<T>", i) #>> getObjects, Func<List<T>, List<T>, List<T>> exceptFunc,
             CancellationToken token, Action<Type, int> errorCallback, Func<bool> shouldStop, bool allowMultiple = false)
        {
            var before = <#= CallFunc("getObjects", "token", i) #>;

            <#= CallFunc("createObject", "token", i) #>;

            var after = <#= CallFunction("ResolveObject", "getObjects, token, a => exceptFunc(before, a).Any(), errorCallback: errorCallback, shouldStop: shouldStop", i) #>;

            var newObjects = exceptFunc(before, after);

            if(!allowMultiple && newObjects.Count > 1)
            {
                var typeName = typeof (T).Name;

                IEnumerable<string> names;

                if (typeof (PrtgObject).IsAssignableFrom(typeof (T)))
                {
                    var objs = newObjects.Cast<PrtgObject>();

                    names = objs.Select(o => $"'{o.Name}' (ID: {o.Id})");
                }
                else
                    names = newObjects.Select(o => $"'{o}'");

                var str = $"Could not uniquely identify created {typeName}: multiple new objects ({string.Join(", ", names)}) were found under parent object. Did you create an additional object with the same type or name under the parent while resolution was occurring?";

                throw new ObjectResolutionException(str);
            }

            return <#= CallFunction("CleanObjects", "newObjects, token", i) #>;
        }

        internal <#= GetSignature("ResolveObject", "List<T>", i) #><T>(Func<CancellationToken, <#= GetFuncRet("List<T>", i) #>> getObjects, CancellationToken token, Func<List<T>, bool> recordsFound, string resolutionError = "Could not resolve object",
            Type trueType = null, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            List<T> @object;

            var retriesRemaining = 4;
            var delay = 3;

            do
            {
                @object = <#= CallFunc("getObjects", "token", i) #>;

                if (!recordsFound(@object))
                {
                    if (retriesRemaining == 0)
                    {
                        throw new ObjectResolutionException($"{resolutionError}: PRTG is taking too long to create the object. Confirm the object has been created in the Web UI and then attempt resolution again manually");
                    }

                    var type = trueType ?? typeof (T);

                    errorCallback?.Invoke(type, retriesRemaining);
                    retriesRemaining--;

#if DEBUG
                    if (!UnitTest())
#endif
                        <#= WaitOne("delay * 1000", "token", i) #>

                    delay *= 2;
                }

                if (shouldStop?.Invoke() == true)
                    break;

            } while (!recordsFound(@object));

            return @object;
        }
        
        private <#= GetSignature("CleanObjects", "List<T>", i) #><T>(List<T> newObjects, CancellationToken token)
        {
            if (newObjects.All(o => o is Sensor))
            {
                var sensors = newObjects.Cast<Sensor>().ToList();

                bool modified = false;

                foreach (var obj in sensors)
                {
                    //PRTG may sometimes prepend spaces to the front of the sensor name. This can even happen
                    //in the Web UI
                    if (obj.Name.StartsWith(" "))
                    {
                        modified = true;
                        <#= CallAsyncTokenFunction("RenameObject", "obj.Id, obj.Name.Trim(' ')", "token", i) #>;
                    }
                }

                if(modified)
                    newObjects = (<#= CallFunction("GetSensors", "Property.Id, sensors.Select(s => s.Id), token", i) #>).Cast<T>().ToList();
            }

            return newObjects;
        }

<#
}
#>
        //######################################
        // AddNotificationTriggerInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetSignature("AddNotificationTriggerInternal", "List<NotificationTrigger>", i)#>(TriggerParameters parameters, bool resolve,
            CancellationToken token, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            if (resolve)
            {
                <#= DeclareTokenAction0("addTrigger", "SetNotificationTriggerInternal", "parameters", i) #>;
                <#= DeclareTokenFuncThen0("getTrigger", "GetNotificationTriggersInternal", "parameters.ObjectId", "List<NotificationTrigger>", ".Where(r => !r.Inherited).ToList();", i) #>

                var objs = <#= CallFunction("ResolveWithDiff", "addTrigger, getTrigger, (b, a) => ResponseParser.ExceptTrigger(b, a, parameters), token, errorCallback, shouldStop", i) #>;

                return objs;
            }
            else
            {
                <#= CallFunction("SetNotificationTriggerInternal", "parameters, token", i) #>;

                return null;
            }
        }

<#
}
#>
        //######################################
        // GetObject
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetAsyncTokenSignature("GetObjectInternal", "PrtgObject", "int objectId, bool resolve", "token", i)#>
        {
            var objs = <#= CallAsyncTokenFunction("GetObjects", "Property.Id, objectId", "token", i) #>;

            if (objs.Count != 1)
                return objs.SingleObject(objectId);

            var obj = objs.Single();

            if (resolve)
            {
                switch (obj.Type.Value)
                {
                    case ObjectType.Sensor:       return <#= CallAsyncTokenFunction("GetSensor", "objectId", "token", i) #>;
                    case ObjectType.Device:       return <#= CallAsyncTokenFunction("GetDevice", "objectId", "token", i) #>;
                    case ObjectType.Group:        return <#= CallAsyncTokenFunction("GetGroup", "objectId", "token", i) #>;
                    case ObjectType.Probe:        return <#= CallAsyncTokenFunction("GetProbe", "objectId", "token", i) #>;
                    case ObjectType.Notification: return <#= CallAsyncTokenFunction("GetNotificationAction", "objectId", "token", i) #>;
                    case ObjectType.Schedule:     return <#= CallAsyncTokenFunction("GetSchedule", "objectId", "token", i) #>;
                    default:
                        return obj;
                }
            }

            return obj;
        }

<#
}
#>
        //######################################
        // GetSystemInfoInternal
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        internal <#= GetGenericTokenSignature("GetSystemInfoInternal", "List<T>", "T", "int deviceId", "token", i)#> where T : IDeviceInfo
        {
            var parameters = new SystemInfoParameters<T>(deviceId);

            <#= DeclareFunc("func", "m", "HttpResponseMessage", "ParseSystemInfoResponse", "m, parameters.Columns", "string", i) #>;

            var info = <#= CallGenericFunction("ObjectEngine.GetObject", "SysInfoData<T>", "parameters, func, token: token", i) #>;

            foreach (var item in info.Items)
                item.DeviceId = deviceId;

            return info.Items;
        }

        internal <#= GetAsyncTokenSignature("GetSystemInfoInternal", "List<IDeviceInfo>", "int deviceId, SystemInfoType type", "token", i)#>
        {
            switch (type)
            {
                case SystemInfoType.System:
                    return (<#= CallGenericAsyncTokenFunction("GetSystemInfo", "deviceId", "DeviceSystemInfo", "token", i) #>).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Hardware:
                    return (<#= CallGenericAsyncTokenFunction("GetSystemInfo", "deviceId", "DeviceHardwareInfo", "token", i) #>).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Software:
                    return (<#= CallGenericAsyncTokenFunction("GetSystemInfo", "deviceId", "DeviceSoftwareInfo", "token", i) #>).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Processes:
                    return (<#= CallGenericAsyncTokenFunction("GetSystemInfo", "deviceId", "DeviceProcessInfo", "token", i) #>).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Services:
                    return (<#= CallGenericAsyncTokenFunction("GetSystemInfo", "deviceId", "DeviceServiceInfo", "token", i) #>).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Users:
                    return (<#= CallGenericAsyncTokenFunction("GetSystemInfo", "deviceId", "DeviceUserInfo", "token", i) #>).Cast<IDeviceInfo>().ToList();
                default:
                    throw new NotImplementedException($"Don't know how to get system info for device info type '{type}'");
            }
        }

<#
}
#>
        //######################################
        // ParseSystemInfoResponse
        //######################################

<#
for(int i = 0; i < 2; i++)
{
#>
        private <#= GetSignature("ParseSystemInfoResponse", "string", i) #>(HttpResponseMessage response, SysInfoProperty[] columns)
        {
            var responseText = <#= AwaitOrForceResult("response.Content.ReadAsStringAsync()", i) #>

            return SysInfoJsonCleaner.Clean(responseText, columns);
        }
<#
if(i == 0)
    WriteLine("");
}
#>
    }
}
